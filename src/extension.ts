import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';

// Default folders/files to ignore
const DEFAULT_IGNORE = new Set([
  'node_modules',
  'build',
  'dist',
  'out',
  '.dart_tool',
  '.git',
  '.DS_Store',
  'flutter_plugins',
  '.idea',
  '.vscode',
  '__pycache__',
  'coverage',
  'tmp',
  'temp',
  '.next',
  'venv',
  '.env',
  'logs',
  'npm-debug.log',
  'yarn-error.log'
]);

function isIgnored(item: string): boolean {
  return DEFAULT_IGNORE.has(item) || item.startsWith('.') || item.endsWith('.log');
}

function buildTree(dir: string, prefix = '', isLast = true, depth = 0, maxDepth = 10): string {
  if (depth > maxDepth) return '';

  try {
    const items = fs.readdirSync(dir).filter(item => !isIgnored(item));
    if (items.length === 0) return '';

    const sorted = items.sort((a, b) => {
      const aIsDir = fs.statSync(path.join(dir, a)).isDirectory();
      const bIsDir = fs.statSync(path.join(dir, b)).isDirectory();
      if (aIsDir && !bIsDir) return -1;
      if (!aIsDir && bIsDir) return 1;
      return a.localeCompare(b);
    });

    let tree = '';

    sorted.forEach((item, index) => {
      const isLastItem = index === sorted.length - 1;
      const currentPrefix = prefix + (isLast ? '    ' : '‚îÇ   ');
      const line = prefix + (isLastItem ? '‚îî‚îÄ‚îÄ ' : '‚îú‚îÄ‚îÄ ') + item;
      const fullPath = path.join(dir, item);

      tree += line + '\n';

      if (fs.statSync(fullPath).isDirectory()) {
        tree += buildTree(fullPath, currentPrefix, isLastItem, depth + 1, maxDepth);
      }
    });

    return tree;
  } catch (err) {
    console.error('Error building tree:', err);
    return '';
  }
}

function getTimestamp(): string {
  return new Date().toLocaleString(undefined, {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
    timeZoneName: 'short'
  });
}

export function activate(context: vscode.ExtensionContext) {
  const disposable = vscode.commands.registerCommand('doctree.generateTree', async () => {
    const folder = vscode.workspace.workspaceFolders?.[0];
    if (!folder) {
      vscode.window.showWarningMessage('üìÅ Open a project folder first.');
      return;
    }

    const rootPath = folder.uri.fsPath;
    const tree = buildTree(rootPath, '', true, 0, 8);

    if (!tree.trim()) {
      vscode.window.showErrorMessage('‚ùå Could not generate project structure.');
      return;
    }

    const projectName = path.basename(rootPath);
    const timestamp = getTimestamp();

    const header = `# Project Structure: \`${projectName}\`

> üìÇ Auto-generated directory tree for documentation purposes.

_Last updated: **${timestamp}**_

\`\`\`
`;
    const footer = `
\`\`\`

> ‚ö†Ô∏è **This file is auto-generated by the [Doctree](https://marketplace.visualstudio.com/items?itemName=...) VS Code extension.**  
> Do not edit manually‚Äîchanges will be overwritten on next generation.
`;

    const doctreeContent = header + tree + footer;
    const doctreePath = path.join(rootPath, 'DOCTREE.md');

    try {
      fs.writeFileSync(doctreePath, doctreeContent, 'utf8');
      vscode.window.showInformationMessage('‚úÖ DOCTREE.md regenerated with current project structure.');

      // Open the file for visibility
      const doc = await vscode.workspace.openTextDocument(vscode.Uri.file(doctreePath));
      await vscode.window.showTextDocument(doc, { preview: false });
    } catch (err) {
      console.error('Failed to write DOCTREE.md:', err);
      vscode.window.showErrorMessage('‚ö†Ô∏è Failed to write DOCTREE.md');
    }
  });

  context.subscriptions.push(disposable);
}

export function deactivate() {}